<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –¢–∞–Ω—á–∏–∫–∏: –ì–∏–≥–∞–Ω—Ç—Å–∫–∞—è –±–∏—Ç–≤–∞</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        #hud {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            color: #ffaa00;
            padding: 12px 24px;
            border-radius: 30px;
            font-size: 28px;
            font-weight: bold;
            border: 2px solid #ff8800;
            box-shadow: 0 0 20px rgba(255,136,0,0.5);
            backdrop-filter: blur(5px);
            z-index: 20;
            pointer-events: none;
        }
        #hud span {
            color: white;
            margin-left: 10px;
        }
        #minimap {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 240px;
            height: 240px;
            border-radius: 50%;
            border: 3px solid #aaa;
            background: #1a2a1a;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
            overflow: hidden;
            z-index: 30;
            pointer-events: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255,255,255,0.2);
            border: 2px solid rgba(255,0,0,0.8);
            box-shadow: 0 0 15px red;
            z-index: 40;
            pointer-events: none;
        }
        #crosshair::before, #crosshair::after {
            content: '';
            position: absolute;
            background: red;
        }
        #crosshair::before {
            width: 20px;
            height: 2px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #crosshair::after {
            width: 2px;
            height: 20px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        #hint {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ccc;
            font-size: 14px;
            background: rgba(0,0,0,0.4);
            padding: 6px 12px;
            border-radius: 20px;
            z-index: 50;
        }
    </style>
</head>
<body>
    <div id="hud">üí• –°—á—ë—Ç: <span id="score">0</span></div>
    <div id="minimap"><canvas id="minimap-canvas" width="240" height="240"></canvas></div>
    <div id="crosshair"></div>
    <div id="hint">WASD ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ | –ü—Ä–æ–±–µ–ª ‚Äî –æ–≥–æ–Ω—å | üéß 3 –∑–≤—É–∫–æ–≤—ã—Ö —Ñ–∞–π–ª–∞</div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.126.0/build/three.module.js"
            }
        }
    </script>

    <script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'https://unpkg.com/three@0.126.0/examples/jsm/controls/OrbitControls.js';

// --- –ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Å—Ü–µ–Ω—ã, –∫–∞–º–µ—Ä—ã, —Ä–µ–Ω–¥–µ—Ä–µ—Ä–∞ ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 150, 400);

const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 500);
camera.position.set(0, 12, 25);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.shadowMap.bias = 0.0001;
document.body.appendChild(renderer.domElement);

// --- –û—Å–≤–µ—â–µ–Ω–∏–µ ---
const ambient = new THREE.AmbientLight(0x404060);
scene.add(ambient);

const sun = new THREE.DirectionalLight(0xffeedd, 1.5);
sun.position.set(50, 100, 50);
sun.castShadow = true;
sun.receiveShadow = true;
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
sun.shadow.camera.left = -100;
sun.shadow.camera.right = 100;
sun.shadow.camera.top = 100;
sun.shadow.camera.bottom = -100;
sun.shadow.camera.near = 10;
sun.shadow.camera.far = 200;
scene.add(sun);

const fillLight = new THREE.PointLight(0x4466ff, 0.6);
fillLight.position.set(-30, 20, -30);
scene.add(fillLight);

// --- –ì–æ—Ä—ã (–±–æ–ª—å—à–∏–µ –º–µ—à–∏ –Ω–∞ –∑–∞–¥–Ω–µ–º –ø–ª–∞–Ω–µ) ---
function createMountain(x, z, scale) {
    const group = new THREE.Group();
    const rockMat = new THREE.MeshStandardMaterial({ color: 0x6a5a4a, roughness: 0.8, emissive: 0x000000 });
    for (let i = 0; i < 5; i++) {
        const h = 20 + Math.random() * 15;
        const geo = new THREE.ConeGeometry(8 * scale * (1 - i*0.15), h, 8);
        const mesh = new THREE.Mesh(geo, rockMat);
        mesh.position.y = h/2 - 5;
        mesh.position.x = (Math.random()-0.5)*6;
        mesh.position.z = (Math.random()-0.5)*6;
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        group.add(mesh);
    }
    group.position.set(x, -2, z);
    scene.add(group);
}
createMountain(-150, -150, 2.5);
createMountain(180, 170, 3.0);
createMountain(200, -200, 2.2);
createMountain(-200, 200, 2.8);
createMountain(-180, 180, 2.0);
createMountain(150, -180, 2.1);

// --- –†–µ–ª—å–µ—Ñ (—Ö–æ–ª–º–∏—Å—Ç–∞—è –∑–µ–º–ª—è —Å —Ç—Ä–∞–≤–æ–π) ---
const groundWidth = 400;
const groundSegments = 128;
const groundGeo = new THREE.PlaneGeometry(groundWidth, groundWidth, groundSegments, groundSegments);
groundGeo.rotateX(-Math.PI / 2);
const positionAttribute = groundGeo.attributes.position;
for (let i = 0; i < positionAttribute.count; i++) {
    const x = positionAttribute.getX(i);
    const z = positionAttribute.getZ(i);
    let y = 0;
    y += Math.sin(x * 0.05) * Math.cos(z * 0.05) * 3;
    y += Math.sin(x * 0.1) * 1.5;
    y += Math.cos(z * 0.08) * 2;
    positionAttribute.setY(i, y);
}
groundGeo.computeVertexNormals();

const groundMat = new THREE.MeshStandardMaterial({ color: 0x3c5e3c, roughness: 0.9, emissive: 0x0a1a0a });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.receiveShadow = true;
ground.castShadow = true;
ground.position.y = 0;
scene.add(ground);

// –¢—Ä–∞–≤–∞ (—Ç—ã—Å—è—á–∏ —Å–ø—Ä–∞–π—Ç–æ–≤ –∏–ª–∏ —á–∞—Å—Ç–∏—Ü? –ò—Å–ø–æ–ª—å–∑—É–µ–º –º–Ω–æ–≥–æ –º–µ–ª–∫–∏—Ö –ø–ª–æ—Å–∫–æ—Å—Ç–µ–π —Å —Ç–µ–∫—Å—Ç—É—Ä–æ–π —Ç—Ä–∞–≤—ã)
// –£–ø—Ä–æ—Å—Ç–∏–º: –¥–æ–±–∞–≤–∏–º –º–Ω–æ–≥–æ –∫—Ä–æ—à–µ—á–Ω—ã—Ö —Ü–∏–ª–∏–Ω–¥—Ä–æ–≤ (—Ç—Ä–∞–≤–∏–Ω–æ–∫) –¥–ª—è —Ä–µ–∞–ª–∏–∑–º–∞, –Ω–æ –Ω–µ –ø–µ—Ä–µ–≥—Ä—É–∂–∞–µ–º.
for (let i = 0; i < 2000; i++) {
    const x = (Math.random() - 0.5) * 380;
    const z = (Math.random() - 0.5) * 380;
    const y = getHeightAt(x, z) + 0.1;
    if (Math.random() > 0.3) {
        const bladeGeo = new THREE.ConeGeometry(0.1, 0.5, 4);
        const bladeMat = new THREE.MeshStandardMaterial({ color: 0x3a7a3a });
        const blade = new THREE.Mesh(bladeGeo, bladeMat);
        blade.position.set(x, y, z);
        blade.castShadow = true;
        blade.receiveShadow = true;
        scene.add(blade);
    }
}

function getHeightAt(x, z) {
    let y = 0;
    y += Math.sin(x * 0.05) * Math.cos(z * 0.05) * 3;
    y += Math.sin(x * 0.1) * 1.5;
    y += Math.cos(z * 0.08) * 2;
    return y;
}

// --- –î–µ—Ä–µ–≤—å—è (–º–Ω–æ–≥–æ, —Å –∫–æ–ª–ª–∏–∑–∏—è–º–∏) ---
const trees = [];
function createTree(x, z) {
    const group = new THREE.Group();
    const h = getHeightAt(x, z);
    
    const trunkGeo = new THREE.CylinderGeometry(0.8, 1.2, 5);
    const trunkMat = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
    const trunk = new THREE.Mesh(trunkGeo, trunkMat);
    trunk.position.y = h + 2.5;
    trunk.castShadow = true;
    trunk.receiveShadow = true;
    group.add(trunk);
    
    const foliageMat = new THREE.MeshStandardMaterial({ color: 0x2a7a2a });
    for (let i = 0; i < 5; i++) {
        const foliageGeo = new THREE.ConeGeometry(1.5 - i*0.2, 2, 6);
        const foliage = new THREE.Mesh(foliageGeo, foliageMat);
        foliage.position.y = h + 4.5 + i * 1.2;
        foliage.castShadow = true;
        foliage.receiveShadow = true;
        group.add(foliage);
    }
    
    group.position.set(x, 0, z);
    scene.add(group);
    trees.push(group);
}
for (let i = 0; i < 300; i++) {
    const x = (Math.random() - 0.5) * 350;
    const z = (Math.random() - 0.5) * 350;
    // –∏–∑–±–µ–≥–∞–µ–º —Ü–µ–Ω—Ç—Ä–∞ –≥–¥–µ —Å–ø–∞–≤–Ω–∏–º—Å—è
    if (Math.sqrt(x*x + z*z) < 15) continue;
    createTree(x, z);
}

// --- –ó–≤—É–∫–∏ ---
const audioListener = new THREE.AudioListener();
camera.add(audioListener);

const soundKill = new THREE.Audio(audioListener);
const soundGoing = new THREE.Audio(audioListener);
const soundShoot = new THREE.Audio(audioListener);

let audioLoaded = false;
function loadSounds() {
    try {
        const loader = new THREE.AudioLoader();
        loader.load('audio_kill.mp3', (buffer) => { soundKill.setBuffer(buffer); soundKill.setVolume(0.7); });
        loader.load('audio_going.mp3', (buffer) => { soundGoing.setBuffer(buffer); soundGoing.setVolume(0.3); soundGoing.setLoop(true); });
        loader.load('audio_shoot.mp3', (buffer) => { soundShoot.setBuffer(buffer); soundShoot.setVolume(0.5); });
        audioLoaded = true;
    } catch (e) { console.warn('–ê—É–¥–∏–æ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω–æ'); }
}
loadSounds();

// --- –ß–∞—Å—Ç–∏—Ü—ã –¥–ª—è –∏—Å–∫—Ä ---
const sparkGeometry = new THREE.BufferGeometry();
const sparkMaterial = new THREE.PointsMaterial({ color: 0xffaa00, size: 0.3 });
const sparks = new THREE.Points(sparkGeometry, sparkMaterial);
scene.add(sparks);
let sparkPositions = [];

// --- –§—É–Ω–∫—Ü–∏—è —Å–æ–∑–¥–∞–Ω–∏—è –∏—Å–∫—Ä ---
function emitSparks(position, count=10) {
    for (let i=0; i<count; i++) {
        sparkPositions.push(position.x + (Math.random()-0.5)*2, position.y+1, position.z + (Math.random()-0.5)*2);
    }
    if (sparkPositions.length > 1000) sparkPositions.splice(0, 300);
    sparkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(sparkPositions, 3));
}

// --- –ö–ª–∞—Å—Å —Ç–∞–Ω–∫–∞ (–æ–±—â–∏–π) ---
class Tank {
    constructor(isEnemy = false, pos = null) {
        this.group = new THREE.Group();
        this.isEnemy = isEnemy;
        this.health = 100;
        this.lastShot = 0;
        this.aiState = 'patrol'; // patrol, aim, shoot, retreat
        this.aiTimer = 0;
        this.targetDirection = new THREE.Vector3();
        this.speed = isEnemy ? 0.1 : 0.15;
        this.turretRotation = 0;
        
        // –ö–æ—Ä–ø—É—Å (—Å–≥–ª–∞–∂–µ–Ω–Ω—ã–π)
        const bodyGeo = new THREE.CylinderGeometry(1.6, 1.6, 1.2, 8);
        const bodyMat = new THREE.MeshStandardMaterial({ color: isEnemy ? 0x8b3a3a : 0x3a6ea5, roughness: 0.3, metalness: 0.6 });
        const body = new THREE.Mesh(bodyGeo, bodyMat);
        body.position.y = 0.6;
        body.castShadow = true;
        body.receiveShadow = true;
        this.group.add(body);
        
        // –ì—É—Å–µ–Ω–∏—á–Ω—ã–µ –ª–µ–Ω—Ç—ã (—Ç–æ—Ä—ã)
        const trackMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 });
        for (let side = -1; side <= 1; side+=2) {
            const trackGeo = new THREE.TorusGeometry(1.1, 0.25, 6, 16, Math.PI);
            const track = new THREE.Mesh(trackGeo, trackMat);
            track.rotation.y = Math.PI/2;
            track.rotation.x = Math.PI/2;
            track.position.set(side*1.3, 0.3, 0);
            track.castShadow = true;
            track.receiveShadow = true;
            this.group.add(track);
        }
        
        // –ë–∞—à–Ω—è (—Å–≥–ª–∞–∂–µ–Ω–Ω—ã–π —Ü–∏–ª–∏–Ω–¥—Ä)
        const turretGeo = new THREE.CylinderGeometry(1.1, 1.1, 0.8, 12);
        const turretMat = new THREE.MeshStandardMaterial({ color: isEnemy ? 0x9b4a4a : 0x4a7eb5, roughness: 0.2, metalness: 0.7 });
        this.turret = new THREE.Mesh(turretGeo, turretMat);
        this.turret.position.y = 1.2;
        this.turret.castShadow = true;
        this.turret.receiveShadow = true;
        this.group.add(this.turret);
        
        // –ü—É—à–∫–∞ (–¥–ª–∏–Ω–Ω—ã–π —Ü–∏–ª–∏–Ω–¥—Ä + —Å—Ñ–µ—Ä–∞ –Ω–∞ –∫–æ–Ω—Ü–µ)
        const barrelGeo = new THREE.CylinderGeometry(0.3, 0.3, 2.5, 8);
        const barrelMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.9 });
        this.barrel = new THREE.Mesh(barrelGeo, barrelMat);
        this.barrel.rotation.x = Math.PI / 2;
        this.barrel.position.set(0, 1.2, 1.3);
        this.barrel.castShadow = true;
        this.barrel.receiveShadow = true;
        this.group.add(this.barrel);
        
        const muzzleGeo = new THREE.SphereGeometry(0.4, 6);
        const muzzleMat = new THREE.MeshStandardMaterial({ color: 0x444444 });
        const muzzle = new THREE.Mesh(muzzleGeo, muzzleMat);
        muzzle.position.set(0, 1.2, 2.7);
        muzzle.castShadow = true;
        this.group.add(muzzle);
        
        if (pos) {
            this.group.position.copy(pos);
            this.group.position.y = getHeightAt(pos.x, pos.z) + 0.6;
        } else {
            // —Å–ª—É—á–∞–π–Ω–∞—è –ø–æ–∑–∏—Ü–∏—è
            const angle = Math.random()*Math.PI*2;
            const dist = 30 + Math.random()*80;
            this.group.position.x = Math.cos(angle)*dist;
            this.group.position.z = Math.sin(angle)*dist;
            this.group.position.y = getHeightAt(this.group.position.x, this.group.position.z) + 0.6;
        }
        this.group.rotation.y = Math.random()*Math.PI*2;
        
        scene.add(this.group);
    }
    
    update(deltaTime, playerTank, enemies, bullets) {
        // –¥–≤–∏–∂–µ–Ω–∏–µ, –ò–ò –∏ –ø—Ä.
        const pos = this.group.position;
        const dir = new THREE.Vector3(0,0,1).applyQuaternion(this.group.quaternion);
        
        if (this.isEnemy) {
            // –ò–ò –≤—Ä–∞–≥–∞
            const toPlayer = new THREE.Vector3().subVectors(playerTank.group.position, pos);
            const distToPlayer = toPlayer.length();
            
            if (distToPlayer < 30) {
                // –≤–∏–¥–∏—Ç –∏–≥—Ä–æ–∫–∞
                this.aiState = 'aim';
                // –ø–æ–≤–æ—Ä–∞—á–∏–≤–∞–µ–º –±–∞—à–Ω—é
                const targetAngle = Math.atan2(toPlayer.x, toPlayer.z);
                this.turret.rotation.y += (targetAngle - this.turret.rotation.y) * 0.1;
                
                if (distToPlayer < 25 && Math.random() < 0.02) {
                    // —Å—Ç—Ä–µ–ª—å–±–∞
                    const now = performance.now() / 1000;
                    if (now - this.lastShot > 1.5) {
                        this.shoot(bullets);
                        this.lastShot = now;
                    }
                }
                if (distToPlayer < 15) {
                    // —Å–ª–∏—à–∫–æ–º –±–ª–∏–∑–∫–æ, –æ—Ç—Å—Ç—É–ø–∏—Ç—å
                    this.aiState = 'retreat';
                }
            } else {
                this.aiState = 'patrol';
            }
            
            // –ø–∞—Ç—Ä—É–ª—å: —Å–ª—É—á–∞–π–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ
            if (this.aiState === 'patrol') {
                this.aiTimer -= deltaTime;
                if (this.aiTimer <= 0) {
                    this.aiTimer = 3 + Math.random()*5;
                    this.targetDirection.set(Math.random()-0.5, 0, Math.random()-0.5).normalize();
                }
                // –ø–ª–∞–≤–Ω—ã–π –ø–æ–≤–æ—Ä–æ—Ç
                const targetRot = Math.atan2(this.targetDirection.x, this.targetDirection.z);
                this.group.rotation.y += (targetRot - this.group.rotation.y) * 0.05;
                this.group.translateZ(this.speed * 0.5);
            } else if (this.aiState === 'aim') {
                // —Å—Ç–æ–∏–º, –∫—Ä—É—Ç–∏–º –±–∞—à–Ω—é
                // –ø–æ–≤–æ—Ä–æ—Ç –∫–æ—Ä–ø—É—Å–∞ –∏–Ω–æ–≥–¥–∞
            } else if (this.aiState === 'retreat') {
                const away = new THREE.Vector3().subVectors(pos, playerTank.group.position).normalize();
                const targetRot = Math.atan2(away.x, away.z);
                this.group.rotation.y += (targetRot - this.group.rotation.y) * 0.1;
                this.group.translateZ(this.speed);
            }
        }
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π —Å –¥–µ—Ä–µ–≤—å—è–º–∏
        for (let tree of trees) {
            const d = pos.distanceTo(tree.position);
            if (d < 3) {
                // –æ—Ç—Ç–∞–ª–∫–∏–≤–∞–Ω–∏–µ
                const push = new THREE.Vector3().subVectors(pos, tree.position).normalize().multiplyScalar(0.5);
                pos.add(push);
                emitSparks(pos, 3);
            }
        }
        
        // –ö–æ–ª–ª–∏–∑–∏–∏ —Å –¥—Ä—É–≥–∏–º–∏ —Ç–∞–Ω–∫–∞–º–∏
        for (let other of enemies) {
            if (other === this) continue;
            const d = pos.distanceTo(other.group.position);
            if (d < 3) {
                const push = new THREE.Vector3().subVectors(pos, other.group.position).normalize().multiplyScalar(0.5);
                pos.add(push);
                other.group.position.sub(push);
                emitSparks(pos, 5);
            }
        }
        
        // –ü–æ–¥–≥–æ–Ω–∫–∞ –≤—ã—Å–æ—Ç—ã
        pos.y = getHeightAt(pos.x, pos.z) + 0.6;
        
        // –ó–≤—É–∫ –µ–∑–¥—ã (—É–ø—Ä–æ—â—ë–Ω–Ω–æ, –≤–∫–ª—é—á–∞–µ–º –µ—Å–ª–∏ –¥–≤–∏–≥–∞–µ–º—Å—è)
        if (audioLoaded && !soundGoing.isPlaying && (this === playerTank || this.isEnemy)) {
            soundGoing.play();
        }
    }
    
    shoot(bullets) {
        const bullet = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x442200 }));
        bullet.castShadow = true;
        const dir = new THREE.Vector3(0,0,1).applyQuaternion(this.turret.quaternion).normalize();
        bullet.position.copy(this.barrel.getWorldPosition(new THREE.Vector3()));
        bullet.userData.velocity = dir.multiplyScalar(1.2);
        bullet.userData.owner = this;
        scene.add(bullet);
        bullets.push(bullet);
        
        if (audioLoaded) soundShoot.play();
    }
}

// --- –ò–≥—Ä–æ–∫ ---
const playerTank = new Tank(false, new THREE.Vector3(0,0,0));

// --- –í—Ä–∞–≥–∏ ---
const enemyTanks = [];
for (let i=0; i<8; i++) {
    enemyTanks.push(new Tank(true));
}

// --- –°–Ω–∞—Ä—è–¥—ã ---
const bullets = [];

// --- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ ---
const keyState = { w:false, a:false, s:false, d:false, space:false };
window.addEventListener('keydown', (e) => {
    switch(e.code) {
        case 'KeyW': keyState.w = true; e.preventDefault(); break;
        case 'KeyA': keyState.a = true; e.preventDefault(); break;
        case 'KeyS': keyState.s = true; e.preventDefault(); break;
        case 'KeyD': keyState.d = true; e.preventDefault(); break;
        case 'Space': keyState.space = true; e.preventDefault(); break;
    }
});
window.addEventListener('keyup', (e) => {
    switch(e.code) {
        case 'KeyW': keyState.w = false; e.preventDefault(); break;
        case 'KeyA': keyState.a = false; e.preventDefault(); break;
        case 'KeyS': keyState.s = false; e.preventDefault(); break;
        case 'KeyD': keyState.d = false; e.preventDefault(); break;
        case 'Space': keyState.space = false; e.preventDefault(); break;
    }
});
window.addEventListener('contextmenu', e => e.preventDefault());

// --- –ú–∏–Ω–∏–∫–∞—Ä—Ç–∞ ---
const minimapCanvas = document.getElementById('minimap-canvas');
const ctx = minimapCanvas.getContext('2d');
function updateMinimap() {
    ctx.clearRect(0,0,240,240);
    ctx.fillStyle = '#1a3a1a';
    ctx.fillRect(0,0,240,240);
    ctx.strokeStyle = '#888';
    ctx.lineWidth = 2;
    ctx.strokeRect(2,2,236,236);
    
    const scale = 200 / 400;
    const cx = 120;
    const cz = 120;
    
    // –≤—Ä–∞–≥–∏
    ctx.fillStyle = 'red';
    for (let e of enemyTanks) {
        const x = cx + e.group.position.x * scale;
        const y = cz - e.group.position.z * scale;
        if (x>0 && x<240 && y>0 && y<240) {
            ctx.beginPath();
            ctx.arc(x, y, 5, 0, 2*Math.PI);
            ctx.fill();
        }
    }
    // –∏–≥—Ä–æ–∫
    ctx.fillStyle = 'blue';
    const px = cx + playerTank.group.position.x * scale;
    const py = cz - playerTank.group.position.z * scale;
    ctx.beginPath();
    ctx.arc(px, py, 7, 0, 2*Math.PI);
    ctx.fill();
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.stroke();
    
    // –¥–µ—Ä–µ–≤—å—è (—Ç–æ—á–∫–∏)
    ctx.fillStyle = 'green';
    for (let tree of trees) {
        const x = cx + tree.position.x * scale;
        const y = cz - tree.position.z * scale;
        if (x>0 && x<240 && y>0 && y<240) {
            ctx.fillRect(x-1, y-1, 2, 2);
        }
    }
}

// --- –°—á—ë—Ç ---
let score = 0;
const scoreSpan = document.getElementById('score');

// --- –¶–∏–∫–ª –∞–Ω–∏–º–∞—Ü–∏–∏ ---
let lastTime = performance.now() / 1000;
function animate() {
    const now = performance.now() / 1000;
    const delta = Math.min(0.1, now - lastTime);
    lastTime = now;
    
    // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–º
    if (keyState.w) playerTank.group.translateZ(playerTank.speed);
    if (keyState.s) playerTank.group.translateZ(-playerTank.speed*0.6);
    if (keyState.a) playerTank.group.rotation.y += 0.03;
    if (keyState.d) playerTank.group.rotation.y -= 0.03;
    if (keyState.space) {
        const nowTime = performance.now()/1000;
        if (nowTime - playerTank.lastShot > 0.8) {
            playerTank.shoot(bullets);
            playerTank.lastShot = nowTime;
        }
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Å–µ—Ö —Ç–∞–Ω–∫–æ–≤
    playerTank.update(delta, playerTank, enemyTanks, bullets);
    for (let e of enemyTanks) {
        e.update(delta, playerTank, enemyTanks, bullets);
    }
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–Ω–∞—Ä—è–¥–æ–≤ –∏ –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏–π
    for (let i = bullets.length-1; i>=0; i--) {
        const b = bullets[i];
        b.position.add(b.userData.velocity);
        // –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤ –∏–≥—Ä–æ–∫–∞
        if (b.userData.owner !== playerTank) {
            const dist = b.position.distanceTo(playerTank.group.position);
            if (dist < 2) {
                // –∏–≥—Ä–æ–∫ –ø–æ–¥–±–∏—Ç
                if (audioLoaded) soundKill.play();
                emitSparks(playerTank.group.position, 20);
                // –≤–æ–∑—Ä–æ–∂–¥–µ–Ω–∏–µ
                playerTank.group.position.set(0,0,0);
                // –≤—Ä–∞–≥–∏ —Ç–æ–∂–µ –≤–æ–∑—Ä–æ–∂–¥–∞—é—Ç—Å—è, –Ω–æ –Ω–µ –±—É–¥–µ–º —É—Å–ª–æ–∂–Ω—è—Ç—å, –ø—Ä–æ—Å—Ç–æ —É–¥–∞–ª–∏–º –ø–æ–¥–±–∏—Ç–æ–≥–æ –≤—Ä–∞–≥–∞
                scene.remove(b);
                bullets.splice(i,1);
                continue;
            }
        }
        // –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –≤–æ –≤—Ä–∞–≥–æ–≤
        for (let j = enemyTanks.length-1; j>=0; j--) {
            const enemy = enemyTanks[j];
            if (b.userData.owner === enemy) continue;
            const dist = b.position.distanceTo(enemy.group.position);
            if (dist < 2) {
                // —É–Ω–∏—á—Ç–æ–∂–µ–Ω
                if (audioLoaded) soundKill.play();
                emitSparks(enemy.group.position, 20);
                scene.remove(enemy.group);
                enemyTanks.splice(j,1);
                // –Ω–æ–≤—ã–π –≤—Ä–∞–≥
                enemyTanks.push(new Tank(true));
                score += 10;
                scoreSpan.innerText = score;
                // —É–¥–∞–ª–∏—Ç—å –ø—É–ª—é
                scene.remove(b);
                bullets.splice(i,1);
                break;
            }
        }
        // —É–¥–∞–ª–µ–Ω–∏–µ –ø—É–ª–∏ –¥–∞–ª–µ–∫–æ
        if (Math.abs(b.position.x) > 200 || Math.abs(b.position.z) > 200 || b.position.y < -10) {
            scene.remove(b);
            bullets.splice(i,1);
        }
    }
    
    // –ö–∞–º–µ—Ä–∞ —Å–ª–µ–¥–æ–≤–∞–Ω–∏—è
    const camOffset = new THREE.Vector3(0, 8, -15).applyQuaternion(playerTank.group.quaternion);
    camera.position.lerp(playerTank.group.position.clone().add(camOffset), 0.1);
    camera.lookAt(playerTank.group.position.clone().add(new THREE.Vector3(0,2,0)));
    
    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏—Å–∫—Ä
    if (sparkPositions.length > 0) {
        sparkPositions = sparkPositions.filter((_, i) => i % 3 !== 0); // –ø—Ä–æ—Å—Ç–æ–µ –∑–∞—Ç—É—Ö–∞–Ω–∏–µ
        sparkGeometry.setAttribute('position', new THREE.Float32BufferAttribute(sparkPositions, 3));
    }
    
    // –ú–∏–Ω–∏–∫–∞—Ä—Ç–∞
    updateMinimap();
    
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
}
animate();

// --- –†–µ—Å–∞–π–∑ ---
window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

window.focus();
    </script>
</body>
</html>